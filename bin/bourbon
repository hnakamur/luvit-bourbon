#!/usr/bin/env luvit

--[[
Copyright 2012 Rackspace

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS-IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
--]]

local fs = require('fs')
local Path = require('path')
local debugm = require('debug')
local fmt = require('string').format

local options = require('options')
local async = require('async')
local bourbon = require(__dirname .. '/..')

local argv = options
  .usage('Usage: ./bourbon -p <path to tests directory>')
  .describe('p', 'path to the tests directory')
  .alias ({p='path'})
  .demand({'p'})
  .argv("p:")

local failed = 0

local function runit(filePath, callback)
  local status, mod = pcall(require, filePath)

  if status ~= true then
    process.stdout:write(fmt('Error loading test module [%s]: %s\n\n', filePath, mod))
    callback()
    return
  end

  process.stdout:write(fmt('Executing test module [%s]\n\n', filePath))
  bourbon.run(nil, mod, function(err, stats)
    process.stdout:write('\n')

    if stats then
      failed = failed + stats.failed
    end

    callback(err)
  end)
end

function run()
  local testsPath = argv.args.p

  -- set the exitCode to error in case we trigger some
  -- bug that causes us to exit the loop early
  process.exitCode = 1

  testsPath = Path.resolve(process.cwd(), testsPath)

  fs.readdir(testsPath, function(err, files)
    if err then
      p(err)
      return
    end

    async.forEachSeries(files, function(file, callback)
      local filePath = Path.join(testsPath, file)

      if file:find('.lua') then
        runit(filePath, callback)
      end
    end,

    function(err)
      if err then
        p(err)
        debugm.traceback(err)
      end

      process.exitCode = 0
      process.exit(failed)
    end)
  end)
end

run()
